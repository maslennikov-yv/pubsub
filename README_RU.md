# Система Публикации/Подписки с ограничением по времени
## Подходит для опроса группы датчиков

Это потокобезопасная реализация системы публикации/подписки (pub-sub) на Go, которая позволяет подписчикам ожидать события с механизмом таймаута. Особенно полезна для сценариев типа опроса данных датчиков, где необходимо собрать ответы от нескольких источников в течение ограниченного времени.

## Ключевые особенности

### 1. **Простой дизайн API**
- Создание хаба и подписчиков с минимальной настройкой
- Подписка на события по строковым ключам
- Ожидание событий с настраиваемым таймаутом
- Публикация событий с возвратом статуса успеха/неудачи

### 2. **Поведение при таймауте**
- Если все подписанные события произошли до таймаута: немедленно возвращает полные результаты
- Если произошел таймаут: возвращает только события, которые были получены вовремя
- Неблокирующая операция с graceful degradation

### 3. **Перезапись событий**
- Если один и тот же ключ получает несколько событий в течение периода таймаута, сохраняется только последнее событие
- Это предотвращает устаревшие данные и гарантирует, что подписчики получают самую свежую информацию

### 4. **Обратная связь от издателя**
- \`Publish()\` возвращает \`true\`, если хотя бы один подписчик получил событие
- \`Publish()\` возвращает \`false\`, если никто не слушает этот ключ
- Позволяет издателям знать, потребляются ли их сообщения

## Пример использования

```go
// Создаем хаб pub-sub
hub := NewPubSub()
subscriber := hub.NewSubscriber()

// Подписываемся на события по строковому ключу
subscriber.Subscribe("foo")
subscriber.Subscribe("buz")

// Ждем до 1 секунды для событий
results := subscriber.Wait(time.Second * 1)

// Публикуем события из других горутин
hub.Publish("foo", map[string]int{"foo": 90})  // возвращает true
hub.Publish("foo", map[string]int{"foo": 100}) // возвращает true (перезаписывает предыдущее)
hub.Publish("bar", map[string]int{"bar": 50})  // возвращает false (нет подписчиков)

// Результаты будут содержать: {"foo": {"foo": 100}}
// Примечание: "buz" нет в результатах, так как ничего не было опубликовано для него
// Примечание: "foo" содержит последнее значение (100, а не 90)
```

## Преимущества архитектуры

### **Потокобезопасность**
- Все операции защищены мьютексами для предотвращения состояний гонки
- Безопасно для одновременного использования в нескольких горутинах
- Правильная синхронизация с использованием WaitGroups

### **Управление памятью**
- Автоматическая очистка неиспользуемых топиков и подписчиков
- Предотвращение утечек памяти через очистку по таймауту
- Возможности graceful shutdown

### **Устойчивость к ошибкам**
- Восстановление после паники в горутинах с логированием
- Graceful degradation при закрытии компонентов
- Предупреждающие логи вместо крашей для недопустимых операций

## Варианты использования

1. **Сбор данных датчиков**: Опрос нескольких датчиков и сбор ответов в течение временного окна
2. **Коммуникация микросервисов**: Ожидание ответов от нескольких сервисов с таймаутом
3. **Агрегация событий**: Сбор событий из различных источников перед обработкой
4. **Мониторинг в реальном времени**: Сбор обновлений статуса от распределенных компонентов
5. **Пакетная обработка**: Сбор элементов данных до таймаута или завершения

Эта реализация обеспечивает надежную основу для архитектур, управляемых событиями, где критически важны время и надежность.

## Создание подписчика
```go
hub := NewPubSub()
subscriber := hub.NewSubscriber()
```

## Подписка на события по текстовому ключу
```go
subscriber.Subscribe("foo")
subscriber.Subscribe("buz")
```

## Ожидание до таймаута
```go
results := subscriber.Wait(time.Second * 1)
```

Если все события, на которые подписан подписчик, случились до таймаута, завершаем ожидание и возвращаем результат.

Если произошел таймаут, возвращаем только те события, которые успели произойти.

При публикации событий, на которые никто не подписан, возвращается false или true, если событие прочитал как минимум один подписчик.

Если за время таймаута событие с одним и тем же ключом произошло дважды и более раз, подписчику отправляется последнее по времени событие.

## Публикация событий
```go
hub.Publish("foo", map[string]int{"foo":90}) // true
hub.Publish("foo", map[string]int{"foo":100}) // true
hub.Publish("bar", map[string]int{"bar":50}) // false

/*
results:
{"foo":100}
*/
```
